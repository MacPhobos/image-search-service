# Alembic Migration Guide Rails

**Research Date**: 2026-01-11
**Project**: image-search-service
**Purpose**: Document migration patterns, common pitfalls, and guide rails for schema upgrades
**Status**: Active (based on production migration history)

---

## Executive Summary

This document provides guide rails for database schema migrations in the image-search-service project. It is based on analysis of:

- 28+ existing migrations across 30+ days of development
- 3 documented incidents of broken migration chains (multiple heads issues)
- Current Alembic configuration with async SQLAlchemy support
- Successful merge migration patterns that resolved parallel development conflicts

**Key Findings**:
- Project uses **sequential numbered migrations** (001-011) + autogenerated hex IDs for parallel work
- **Multiple heads** have occurred 3+ times, requiring merge migrations
- **Manual migration fixes** included deleting broken merge migrations and correcting down_revision references
- Current setup uses **PostgreSQL + asyncpg** with fallback to SQLite for tests

---

## Table of Contents

1. [Current Migration Configuration](#current-migration-configuration)
2. [Migration Naming Conventions](#migration-naming-conventions)
3. [Makefile Commands](#makefile-commands)
4. [Migration Chain History](#migration-chain-history)
5. [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)
6. [Multiple Heads Resolution](#multiple-heads-resolution)
7. [Best Practices and Guide Rails](#best-practices-and-guide-rails)
8. [Testing Migrations](#testing-migrations)
9. [Appendix: Historical Incidents](#appendix-historical-incidents)

---

## Current Migration Configuration

### Alembic Configuration (`alembic.ini`)

```ini
[alembic]
script_location = %(here)s/src/image_search_service/db/migrations
prepend_sys_path = .
path_separator = os
```

**Key Settings**:
- Migration scripts stored in `src/image_search_service/db/migrations/versions/`
- Database URL configured via environment variable (not hardcoded)
- No post-write hooks configured (ruff/black commented out)

### Environment Configuration (`db/migrations/env.py`)

**Technology Stack**:
- **Database**: PostgreSQL (production) + SQLite (tests)
- **Driver**: asyncpg (async SQLAlchemy)
- **Connection Pool**: NullPool (migrations don't need pooling)
- **Base Model**: `image_search_service.db.models.Base`

**Key Features**:
- ‚úÖ Async migration support via `asyncio.run()`
- ‚úÖ Database URL from `core.config.get_settings()`
- ‚úÖ Offline mode support (for SQL script generation)

**Code Pattern**:
```python
async def run_async_migrations() -> None:
    """Run migrations in async mode."""
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)
    await connectable.dispose()
```

---

## Migration Naming Conventions

### Pattern Analysis

The project uses **two naming patterns**:

#### 1. Sequential Numbered (Preferred for Main Branch)

```
001_initial_migration.py
002_add_training_columns_to_image_assets.py
003_create_training_sessions_table.py
...
011_hash_dedup_fields.py
```

**Format**: `{seq}_{descriptive_name}.py`
- **seq**: Zero-padded 3-digit sequential number (001-999)
- **descriptive_name**: Lowercase snake_case description

**Revision ID Format**: Same as filename (e.g. `"011_hash_dedup_fields"`)

**Usage**: Main development line, linear migration history

#### 2. Autogenerated Hex (For Parallel Work)

```
0d2febc7f1d5_add_resume_fields_to_face_detection_.py
0ea4fdf7fc41_add_face_detection_sessions.py
56f6544da217_add_face_suggestions.py
737ef70e7bab_merge_birth_date_and_unique_index_.py
```

**Format**: `{hex_id}_{descriptive_name}.py`
- **hex_id**: 12-character hexadecimal identifier (Alembic default)
- **descriptive_name**: Auto-generated from migration message

**Usage**: Feature branches, parallel development, merge migrations

### When to Use Each Pattern

| Scenario | Pattern | Revision ID Format | Example |
|----------|---------|-------------------|---------|
| **Main branch sequential work** | Numbered | `"011_descriptive_name"` | `011_hash_dedup_fields.py` |
| **Feature branch (parallel dev)** | Hex | `"0ea4fdf7fc41"` | `0ea4fdf7fc41_add_face_detection_sessions.py` |
| **Merge migration** | Hex | `"737ef70e7bab"` | `737ef70e7bab_merge_birth_date_and_unique_index_.py` |

**Recommendation**: Continue using numbered format for main branch, reserve hex IDs for parallel work that may require merging.

---

## Makefile Commands

### Migration Workflow Commands

```bash
# Create new migration (prompts for message)
make makemigrations

# Apply pending migrations to database
make migrate

# Start database services (Postgres + Redis + Qdrant)
make db-up

# Stop database services
make db-down
```

### Internal Implementation

**makemigrations**:
```makefile
makemigrations: ## Create new migration
	@read -p "Enter migration message: " msg; \
	uv run alembic revision --autogenerate -m "$$msg"
```

**migrate**:
```makefile
migrate: ## Run database migrations
	uv run alembic upgrade head
```

### Direct Alembic Commands

For advanced operations, use `uv run alembic`:

```bash
# Check current version
uv run alembic current

# Check for multiple heads (before creating migration)
uv run alembic heads

# View migration history
uv run alembic history --verbose

# Upgrade to specific version
uv run alembic upgrade <revision_id>

# Downgrade one version
uv run alembic downgrade -1

# Generate SQL script (offline mode)
uv run alembic upgrade head --sql
```

---

## Migration Chain History

### Current Migration Chain (as of 2026-01-11)

```
<base> ‚Üí 001 ‚Üí ce719ca53e7b ‚Üí 002 ‚Üí 003 ‚Üí 004 ‚Üí 005 ‚Üí 006 ‚Üí 007 ‚Üí 008 ‚Üí 009
  ‚Üí e7ccebcb4be7 ‚Üí 0ea4fdf7fc41 ‚Üí 56f6544da217 ‚Üí a1b2c3d4e5f6 ‚Üí 974bfe0f68ed
  ‚Üí 0d2febc7f1d5 ‚Üí a5e555cf5477 ‚Üí 9511886120f4 ‚Üí temporal_proto_001 ‚Üí 010
  ‚Üí 8d46a4ba4167 (branchpoint)
     ‚îú‚îÄ‚Üí f6a668d072bb ‚Üí a8b9c0d1e2f3 ‚Üí b9c0d1e2f3g4 ‚îÄ‚îÄ‚îê
     ‚îî‚îÄ‚Üí c1d2e3f4g5h6 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                          ‚Üì
                                                    737ef70e7bab (mergepoint)
                                                          ‚Üì
                                                    011_hash_dedup_fields (head)
```

**Key Observations**:
- **Linear chain**: 001-010 (main development line)
- **Branch point**: `8d46a4ba4167` (two parallel migrations created from same parent)
- **Merge point**: `737ef70e7bab` (reconciles parallel work)
- **Current head**: `011_hash_dedup_fields`

### Database Tables (28 tables total)

**Core Tables**:
- `image_assets` - Main image metadata and embeddings
- `persons` - Face recognition person entities
- `face_instances` - Individual face detections
- `person_prototypes` - Representative faces for each person
- `face_suggestions` - Auto-propagation suggestions

**Training System**:
- `training_sessions` - Training session management
- `training_subdirectories` - Directory-level tracking
- `training_jobs` - Individual image training jobs
- `training_evidence` - Training metadata and embeddings

**Support Tables**:
- `categories` - Image categorization
- `system_configs` - Configuration key-value store
- `vector_deletion_log` - Qdrant cleanup tracking
- `face_detection_sessions` - Batch detection tracking
- `face_assignment_events` - Audit log for face labeling

---

## Common Pitfalls and Solutions

### 1. Multiple Heads Problem

**Symptom**:
```bash
$ make migrate
FAILED: Multiple head revisions are present for given argument 'heads';
please specify a specific target revision, '<branchname>@head' to
narrow to a specific head, or 'heads' for all heads
```

**Root Cause**: Two migrations created from same parent without coordination

**Example from Project History**:
```
8d46a4ba4167 (parent)
    ‚îú‚îÄ‚Üí f6a668d072bb (developer A adds multi-prototype scoring)
    ‚îî‚îÄ‚Üí c1d2e3f4g5h6 (developer B adds pending suggestion index)
```

**Detection**:
```bash
uv run alembic heads
# Output shows 2+ heads:
# f6a668d072bb (head)
# c1d2e3f4g5h6 (head)
```

**Solution**: See [Multiple Heads Resolution](#multiple-heads-resolution) section below.

---

### 2. Broken down_revision Reference

**Symptom**:
```bash
$ make migrate
KeyError: '974bfe0f68ed'
```

**Root Cause**: Migration references non-existent parent revision ID

**Example from Project History** (Commit 4888f12, later reverted):
```python
# BROKEN: References non-existent revision
down_revision: str | None = "974bfe0f68ed"  # ‚ùå Doesn't exist

# FIXED: Points to actual parent
down_revision: str | None = "a1b2c3d4e5f6"  # ‚úÖ Exists in chain
```

**Detection**:
```bash
# Check if revision exists in history
uv run alembic history | grep "974bfe0f68ed"
# (no output = doesn't exist)

# View full chain to find actual parent
uv run alembic history --verbose
```

**Solution**:
1. Identify the correct parent revision from `alembic history`
2. Edit migration file's `down_revision` field
3. Verify with `uv run alembic upgrade head`

**Prevention**:
- Always run `alembic heads` before creating new migration
- Use `alembic revision --autogenerate` (detects current head automatically)
- Never manually create migrations without checking chain state

---

### 3. Non-Idempotent Operations

**Symptom**:
```bash
$ make migrate
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DuplicateObject)
relation "idx_face_suggestions_pending" already exists
```

**Root Cause**: Migration assumes clean state, fails on re-run

**Example from Project History** (Fixed in commit 3776f7d):
```python
# BROKEN: Fails if index already dropped
op.drop_index("idx_face_suggestions_pending")

# FIXED: Idempotent with if_exists parameter
op.drop_index("idx_face_suggestions_pending", if_exists=True)
```

**Best Practices**:
```python
# ‚úÖ DROP operations - always use if_exists
op.drop_index("idx_name", table_name="table", if_exists=True)
op.drop_column("table", "column", if_exists=True)

# ‚úÖ CREATE operations - check existence first
from sqlalchemy import inspect

def upgrade():
    conn = op.get_bind()
    inspector = inspect(conn)

    # Check if index exists before creating
    indexes = [idx['name'] for idx in inspector.get_indexes('table_name')]
    if 'idx_name' not in indexes:
        op.create_index('idx_name', 'table_name', ['column'])

# ‚úÖ ALTER operations - graceful handling
try:
    op.add_column('table', sa.Column('new_col', sa.String))
except sa.exc.OperationalError:
    pass  # Column already exists, skip
```

---

### 4. Merge Migration Referencing Deleted Revision

**Symptom**:
```bash
$ make migrate
KeyError: '98ab620aa6f9'
```

**Root Cause**: Merge migration points to revision that was deleted from versions/

**Example from Project History** (Commit 57e1e45):
```python
# BROKEN MERGE MIGRATION (deleted in production)
# File: 34534acb6ed1_merge_parallel_migrations.py
revision: str = '34534acb6ed1'
down_revision: Union[str, Sequence[str], None] = (
    '98ab620aa6f9',  # ‚ùå This revision was deleted!
    'f6a668d072bb'
)
```

**Timeline**:
1. **Commit 3776f7d**: Created merge migration `34534acb6ed1` pointing to `98ab620aa6f9`
2. **Later**: Revision `98ab620aa6f9` was deleted (not found in git history)
3. **Commit 57e1e45**: Deleted broken merge migration entirely

**Solution**:
1. **Identify missing revision**: Check `alembic history` for gaps
2. **Options**:
   - **Option A**: Delete the broken merge migration (if not yet deployed)
   - **Option B**: Update merge to point to existing revisions
   - **Option C**: Recreate missing revision (if backed up)

**Example Fix** (from production):
```bash
# Option A was chosen: Delete broken merge migration
rm src/image_search_service/db/migrations/versions/34534acb6ed1_merge_parallel_migrations.py

# Verify chain is healthy
uv run alembic heads
# Output: 011_hash_dedup_fields (head)  ‚úÖ Single head restored
```

**Prevention**:
- Never delete migration files after deployment
- If merge migration needed, verify all parent revisions exist
- Document merge migrations with commit references

---

## Multiple Heads Resolution

### Step-by-Step Resolution Process

#### Step 1: Detect Multiple Heads

```bash
$ uv run alembic heads
f6a668d072bb (head)
c1d2e3f4g5h6 (head)
```

**Diagnosis**: Two independent heads exist, migration chain has forked.

---

#### Step 2: Identify Common Parent

```bash
$ uv run alembic history --verbose
Rev: f6a668d072bb (head)
Parent: 8d46a4ba4167
...

Rev: c1d2e3f4g5h6 (head)
Parent: 8d46a4ba4167
...

Rev: 8d46a4ba4167 (branchpoint)
Parent: 010
```

**Finding**: Both heads branch from `8d46a4ba4167`.

---

#### Step 3: Create Merge Migration

```bash
$ uv run alembic merge -m "merge parallel migrations" f6a668d072bb c1d2e3f4g5h6
Generating merge revision 737ef70e7bab ...
```

**Generated File** (`737ef70e7bab_merge_parallel_migrations.py`):
```python
"""merge parallel migrations

Revision ID: 737ef70e7bab
Revises: f6a668d072bb, c1d2e3f4g5h6
Create Date: 2026-01-10 18:21:32.978882
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa

revision: str = '737ef70e7bab'
down_revision: Union[str, Sequence[str], None] = (
    'f6a668d072bb',  # First parent
    'c1d2e3f4g5h6'   # Second parent
)
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    """Merge point - no schema changes needed."""
    pass

def downgrade() -> None:
    """Downgrade to multiple heads."""
    pass
```

**Key Properties**:
- **No schema changes**: Merge migrations typically have empty upgrade/downgrade
- **Tuple down_revision**: Points to both parents
- **Hex revision ID**: Alembic auto-generates

---

#### Step 4: Verify Merge

```bash
$ uv run alembic heads
737ef70e7bab (head)  # ‚úÖ Single head restored

$ uv run alembic upgrade head
INFO  [alembic.runtime.migration] Running upgrade f6a668d072bb, c1d2e3f4g5h6 -> 737ef70e7bab, merge parallel migrations
```

**Success Criteria**:
- ‚úÖ Only one head exists
- ‚úÖ `alembic upgrade head` runs without errors
- ‚úÖ Both branches merged into single chain

---

#### Step 5: Continue Development

```bash
# Future migrations now build on merge point
$ make makemigrations
Enter migration message: add hash dedup fields

# Generated migration:
# Revision ID: 011_hash_dedup_fields
# Revises: 737ef70e7bab  ‚Üê Points to merge point
```

---

### Merge Migration Template

**Use this template when creating manual merge migrations**:

```python
"""Merge parallel migrations: <branch_1_desc> and <branch_2_desc>

Revision ID: <auto_generated>
Revises: <revision_1>, <revision_2>
Create Date: <timestamp>

Context:
- <revision_1> (<branch_name_1>): <what it changed>
- <revision_2> (<branch_name_2>): <what it changed>
- Both created from parent <parent_revision>

No schema conflicts detected. This merge migration reconciles the fork.
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa

revision: str = '<auto_generated>'
down_revision: Union[str, Sequence[str], None] = (
    '<revision_1>',
    '<revision_2>'
)
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    """Merge point - no schema changes needed.

    Both parent migrations have been applied independently.
    This migration simply reconciles the migration graph.
    """
    pass

def downgrade() -> None:
    """Downgrade to multiple heads state.

    Rolling back this migration restores the fork condition.
    """
    pass
```

---

### When to Use Merge Migrations

**Use Merge Migration When**:
- ‚úÖ Multiple developers created migrations from same parent
- ‚úÖ Feature branches both modified database schema
- ‚úÖ No schema conflicts between branches (different tables/columns)
- ‚úÖ Both migrations are already deployed to some environments

**Do NOT Use Merge Migration When**:
- ‚ùå Migrations have schema conflicts (same column modified differently)
- ‚ùå Only one branch has been deployed (delete extra migration instead)
- ‚ùå Migrations can be reordered without conflicts (use `alembic upgrade <specific_rev>`)

---

## Best Practices and Guide Rails

### üü¢ Green Zone: Always Do This

#### 1. Check for Multiple Heads Before Creating Migration

```bash
# ALWAYS run this first
$ uv run alembic heads
011_hash_dedup_fields (head)  # ‚úÖ Single head = safe to proceed

# Then create migration
$ make makemigrations
```

**Why**: Prevents creating third head and complicating merge.

---

#### 2. Use Autogenerate for Schema Changes

```bash
# ‚úÖ GOOD: Alembic detects schema changes from models
$ make makemigrations
Enter migration message: add user_id to assets

# Alembic auto-generates:
def upgrade() -> None:
    op.add_column('image_assets',
                  sa.Column('user_id', sa.String(36), nullable=True))
```

**Why**: Reduces human error, ensures consistency with SQLAlchemy models.

---

#### 3. Make Migrations Idempotent

```python
# ‚úÖ GOOD: Safe to run multiple times
def upgrade() -> None:
    op.add_column('table', sa.Column('col', sa.String), if_exists=False)
    op.create_index('idx_name', 'table', ['col'], if_exists=False)

def downgrade() -> None:
    op.drop_index('idx_name', 'table', if_exists=True)
    op.drop_column('table', 'col', if_exists=True)
```

**SQLAlchemy 1.4+ Note**: `if_exists` parameter available for most operations.

---

#### 4. Test Migrations Locally Before Committing

```bash
# 1. Apply migration to clean database
$ make db-down && make db-up
$ make migrate

# 2. Verify database state
$ uv run python -c "from image_search_service.db.session import get_engine; \
from sqlalchemy import inspect; \
engine = get_engine(); \
inspector = inspect(engine); \
print(inspector.get_table_names())"

# 3. Test downgrade
$ uv run alembic downgrade -1

# 4. Test upgrade again
$ uv run alembic upgrade head
```

**Why**: Catches errors before they reach production or team members.

---

#### 5. Document Complex Migrations in Docstring

```python
"""Add multi-prototype scoring fields to face_suggestions

Add temporal prototype scoring support:
- similarity_to_prototype: Cosine similarity to person's temporal prototype
- temporal_bucket: Age era classification (infant, child, adult, etc.)
- temporal_confidence: Confidence in temporal classification (0.0-1.0)

This enables age-aware face suggestion ranking for better user experience.

Revision ID: f6a668d072bb
Revises: 8d46a4ba4167
Create Date: 2026-01-10 10:04:00.000000
"""
```

**Why**: Future developers understand context without archeology.

---

### üü° Yellow Zone: Caution Required

#### 1. Manual Schema Changes (Avoid Autogenerate)

**When Needed**:
- Data migrations (UPDATE queries)
- Complex transformations
- Operations autogenerate can't detect

**Example**:
```python
def upgrade() -> None:
    """Backfill perceptual hashes for existing assets."""
    from image_search_service.services.hash_service import compute_phash

    # Manual data migration
    conn = op.get_bind()
    assets = conn.execute("SELECT id, file_path FROM image_assets WHERE perceptual_hash IS NULL")

    for asset_id, file_path in assets:
        phash = compute_phash(file_path)
        conn.execute(
            "UPDATE image_assets SET perceptual_hash = %s WHERE id = %s",
            (phash, asset_id)
        )
```

**Caution**:
- Test with production-like data volumes
- Consider timeouts for large tables
- Add progress logging for long operations

---

#### 2. Dropping Columns with Data

```python
# ‚ö†Ô∏è CAUTION: Data loss risk
def upgrade() -> None:
    """Remove deprecated embedding_model column."""
    op.drop_column('image_assets', 'embedding_model')

def downgrade() -> None:
    """Restore embedding_model column."""
    op.add_column('image_assets',
                  sa.Column('embedding_model', sa.String(50)))
    # ‚ùå Data is LOST - cannot restore
```

**Best Practice**:
1. Add new column
2. Migrate data to new column
3. Deprecate old column (mark as nullable)
4. Wait for grace period (e.g., 1 sprint)
5. Drop old column in separate migration

---

#### 3. Renaming Tables/Columns

**SQLAlchemy 2.0 Recommendation**: Use `op.rename_table()` and `op.alter_column()`

```python
def upgrade() -> None:
    """Rename persons table to people."""
    op.rename_table('persons', 'people')

def downgrade() -> None:
    """Restore persons table name."""
    op.rename_table('people', 'persons')
```

**Caution**:
- Coordinate with app code changes (table name used in models)
- May require app downtime or blue-green deployment
- Check foreign key constraints are updated

---

### üî¥ Red Zone: High Risk - Avoid If Possible

#### 1. Manually Editing Migration Files After Deployment

**Never Do This**:
```python
# ‚ùå DANGER: Migration already applied to production
# File: 009_add_face_detection_tables.py

def upgrade() -> None:
    # Editing this WILL NOT update production database
    op.add_column('face_instances', sa.Column('new_field', sa.String))
```

**Why It Fails**:
- Alembic tracks applied migrations in `alembic_version` table
- Changing applied migration doesn't trigger re-run
- Production and dev databases diverge

**Correct Approach**: Create NEW migration
```bash
$ make makemigrations
Enter migration message: add new_field to face_instances
# Creates 012_add_new_field_to_face_instances.py
```

---

#### 2. Deleting Migration Files After Deployment

**Never Do This**:
```bash
# ‚ùå DANGER: Breaking production migration chain
$ rm src/image_search_service/db/migrations/versions/009_add_face_detection_tables.py
```

**What Breaks**:
- Future migrations reference deleted revision as parent
- `alembic history` shows gaps
- New environments can't apply full migration chain

**Exception**: Migration never deployed AND has no children (check with `alembic history`)

---

#### 3. Skipping Migrations in Production

**Never Do This**:
```bash
# ‚ùå DANGER: Skipping migration to "fix" production
$ uv run alembic stamp <later_revision>  # Marks migration as applied without running
```

**What Breaks**:
- Database schema doesn't match `alembic_version` table
- Future migrations assume skipped changes exist
- Silent schema drift

**Correct Approach**: Fix underlying issue, apply missing migrations

---

## Testing Migrations

### Local Testing Workflow

#### 1. Clean Database Test

```bash
# Full reset test
$ make db-down
$ make db-up
$ make migrate

# Verify success
$ uv run alembic current
011_hash_dedup_fields (head)  # ‚úÖ
```

---

#### 2. Downgrade/Upgrade Test

```bash
# Test reversibility
$ uv run alembic downgrade -1
$ uv run alembic current
737ef70e7bab (head)  # ‚úÖ One step back

$ uv run alembic upgrade +1
$ uv run alembic current
011_hash_dedup_fields (head)  # ‚úÖ Back to head
```

---

#### 3. SQL Script Generation (Dry Run)

```bash
# Generate SQL without applying
$ uv run alembic upgrade head --sql > migration.sql

# Review SQL before applying
$ less migration.sql
```

**Use Case**: Auditing production migrations before deployment

---

#### 4. Pytest Integration

**Test migrations in CI/CD**:

```python
# tests/test_migrations.py
import pytest
from alembic.config import Config
from alembic import command

def test_migrations_run_successfully():
    """Test all migrations apply without errors."""
    alembic_cfg = Config("alembic.ini")

    # Apply all migrations
    command.upgrade(alembic_cfg, "head")

    # Verify current version
    current = command.current(alembic_cfg)
    assert current == "011_hash_dedup_fields"

def test_migrations_are_reversible():
    """Test migrations can be downgraded and re-upgraded."""
    alembic_cfg = Config("alembic.ini")

    # Downgrade all
    command.downgrade(alembic_cfg, "base")

    # Re-upgrade
    command.upgrade(alembic_cfg, "head")

    # Verify head reached
    current = command.current(alembic_cfg)
    assert current == "011_hash_dedup_fields"
```

---

## Appendix: Historical Incidents

### Incident 1: Broken Migration Chain (Dec 31, 2025)

**Commit**: `4888f12` (later reverted in `c623c6e`)

**Symptom**:
```bash
$ make migrate
KeyError: '974bfe0f68ed'
```

**Root Cause**: Migration `0d2febc7f1d5` referenced non-existent parent `974bfe0f68ed`

**Fix Attempted** (Reverted):
```python
# Changed down_revision from non-existent to existing
down_revision: str | None = "a1b2c3d4e5f6"  # Was: "974bfe0f68ed"
```

**Why Reverted**: Unknown (commit message doesn't specify, but likely incorrect parent identified)

**Lessons Learned**:
- Verify parent revision exists with `alembic history | grep <revision>`
- Understand why reference was wrong (typo vs. missing migration)

---

### Incident 2: Multiple Heads from Parallel Development (Jan 8, 2026)

**Commit**: `3776f7d` (successful resolution)

**Symptom**:
```bash
$ make migrate
FAILED: Multiple head revisions are present
```

**Root Cause**: Two migrations created from `8d46a4ba4167`:
- `98ab620aa6f9` (unknown - later deleted)
- `f6a668d072bb` (multi-prototype scoring fields)

**Fix**:
1. Created merge migration `34534acb6ed1`
2. Made `f6a668d072bb` idempotent with `if_exists=True` on drop_index

**Success**: Migration chain restored, both branches merged

---

### Incident 3: Broken Merge Migration (Jan 10, 2026)

**Commit**: `57e1e45` (deleted broken merge)

**Symptom**:
```bash
$ make migrate
KeyError: '98ab620aa6f9'
```

**Root Cause**: Merge migration `34534acb6ed1` (from Incident 2) referenced deleted revision `98ab620aa6f9`

**Fix**:
```bash
# Deleted broken merge migration entirely
$ rm src/image_search_service/db/migrations/versions/34534acb6ed1_merge_parallel_migrations.py
```

**Why Worked**: Revision `98ab620aa6f9` was never deployed, safe to remove merge

**Lessons Learned**:
- Merge migrations are fragile if parent revisions are deleted
- Document why revisions are deleted (missing from git history)
- Consider keeping deleted revisions in git history for reference

---

### Incident 4: Birth Date and Unique Index Parallel Development (Jan 10, 2026)

**Symptom**: Multiple heads from `f6a668d072bb`

**Root Cause**: Two developers created migrations in parallel:
- `b9c0d1e2f3g4` (add birth_date to persons)
- `c1d2e3f4g5h6` (add pending suggestion unique index)

**Fix**: Created merge migration `737ef70e7bab` (still in codebase)

**Success**: Clean merge, no schema conflicts, both features integrated

**Best Practice Demonstrated**: Merge migrations work well when features don't conflict

---

## Recommendations for Guide Rails Document

Based on this research, the guide rails document should include:

### 1. **Pre-Migration Checklist**
```
‚ñ° Run `uv run alembic heads` (verify single head)
‚ñ° Run `uv run alembic current` (know your starting point)
‚ñ° Pull latest main branch (avoid parallel development)
‚ñ° Update SQLAlchemy models first (autogenerate works best)
‚ñ° Test models in interactive session before migration
```

### 2. **Migration Creation Checklist**
```
‚ñ° Use `make makemigrations` (prompts for message)
‚ñ° Review generated migration file (verify schema changes)
‚ñ° Add docstring explaining WHY (not just WHAT)
‚ñ° Make operations idempotent (use if_exists=True)
‚ñ° Test locally: db-down ‚Üí db-up ‚Üí migrate
```

### 3. **Parallel Development Protocol**
```
If working on feature branch with schema changes:
1. Create migration with autogenerate (hex ID expected)
2. Do NOT merge to main until testing complete
3. Before merge: Check `alembic heads` on main
4. If multiple heads detected:
   a. Coordinate with other developer
   b. Decide who creates merge migration
   c. Test merge locally before pushing
5. Document merge in commit message with context
```

### 4. **Emergency Procedures**

**Multiple Heads in Production**:
```bash
# 1. Assess state
uv run alembic heads  # Identify competing heads
uv run alembic history --verbose  # Find common parent

# 2. Create merge migration
uv run alembic merge -m "merge <desc>" <head1> <head2>

# 3. Test merge locally
make db-down && make db-up
make migrate

# 4. Verify single head
uv run alembic heads  # Should show merge point
```

**Broken Migration Reference**:
```bash
# 1. Identify missing revision
uv run alembic upgrade head 2>&1 | grep KeyError

# 2. Find correct parent
uv run alembic history | grep -B 5 -A 5 <broken_migration>

# 3. Options:
#    A. Edit migration file (if never deployed)
#    B. Create new migration with correct reference
#    C. Delete migration (if safe - check children first)
```

### 5. **Naming Convention Standard**

**Propose formal standard**:

```
Main Branch Sequential Format:
{seq}_{action}_{object}[_qualifier]

Examples:
001_initial_migration
002_add_training_columns_to_image_assets
003_create_training_sessions_table
012_drop_deprecated_embedding_model_column

Feature Branch Format:
{hex}_{descriptive_name}

Examples:
0ea4fdf7fc41_add_face_detection_sessions
f6a668d072bb_add_multi_prototype_scoring_fields

Merge Migration Format:
{hex}_merge_{branch1}_and_{branch2}

Examples:
737ef70e7bab_merge_birth_date_and_unique_index_migrations
```

### 6. **Migration Review Checklist (for PRs)**

```
Code Reviewer Verification:
‚ñ° Single migration file added (or merge + explanation)
‚ñ° Migration builds on current head (check down_revision)
‚ñ° Idempotent operations (if_exists used where appropriate)
‚ñ° Docstring explains business context
‚ñ° upgrade() and downgrade() both implemented
‚ñ° No manual SQL without comments explaining why
‚ñ° Tested locally (reviewer asks: "Did you test?")
‚ñ° Models updated to match migration
```

---

## Summary

**Current State**: Healthy migration chain with 28 migrations, single head (`011_hash_dedup_fields`)

**Pain Points Identified**:
- Multiple heads occurred 3+ times (resolved with merge migrations)
- Broken references occurred 2+ times (manual fixes required)
- Migration files occasionally deleted breaking chain

**Strengths**:
- Async SQLAlchemy support working well
- Makefile abstracts complexity
- Team has successfully resolved all incidents
- Good docstrings in recent migrations

**Next Steps**:
1. Formalize naming convention (numbered for main, hex for branches)
2. Add pre-commit hook to check for multiple heads
3. Document merge migration process in CLAUDE.md
4. Consider migration lint tool to catch common errors
5. Add pytest tests for migration chain integrity

---

**Document Author**: Research Agent (Claude Code)
**Research Scope**: Git history (30 days), Migration files (28 total), Makefile analysis
**Confidence Level**: High (based on production evidence and commit messages)
**Recommendation**: Use this document as foundation for formal migration guide in project docs
